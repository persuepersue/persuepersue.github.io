<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ohlinux.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="文章深入源码解析了 2.6.11 版本的基数树实现。 初始化12345678init&#x2F;main.casmlinkage void __init start_kernel(void)&amp;#123;    ...;    radix_tree_init();    ...;&amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="2.6.11版本基数树源码解析">
<meta property="og:url" content="https://ohlinux.com/2-6-11%E7%89%88%E6%9C%AC%E5%9F%BA%E6%95%B0%E6%A0%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="qeandzc的个人小站">
<meta property="og:description" content="文章深入源码解析了 2.6.11 版本的基数树实现。 初始化12345678init&#x2F;main.casmlinkage void __init start_kernel(void)&amp;#123;    ...;    radix_tree_init();    ...;&amp;#125;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-15T03:32:24.000Z">
<meta property="article:modified_time" content="2022-10-31T14:14:24.000Z">
<meta property="article:author" content="qeandzc">
<meta property="article:tag" content="kernel 2.6.11">
<meta property="article:tag" content="基数树">
<meta property="article:tag" content="radix tree">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ohlinux.com/2-6-11%E7%89%88%E6%9C%AC%E5%9F%BA%E6%95%B0%E6%A0%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ohlinux.com/2-6-11%E7%89%88%E6%9C%AC%E5%9F%BA%E6%95%B0%E6%A0%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","path":"2-6-11版本基数树源码解析/","title":"2.6.11版本基数树源码解析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>2.6.11版本基数树源码解析 | qeandzc的个人小站</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">qeandzc的个人小站</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#API"><span class="nav-number">2.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-insert"><span class="nav-number">2.1.</span> <span class="nav-text">radix_tree_insert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-delete"><span class="nav-number">2.2.</span> <span class="nav-text">radix_tree_delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-lookup"><span class="nav-number">2.3.</span> <span class="nav-text">radix_tree_lookup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-tag-set"><span class="nav-number">2.4.</span> <span class="nav-text">radix_tree_tag_set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-tag-clear"><span class="nav-number">2.5.</span> <span class="nav-text">radix_tree_tag_clear</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-tagged"><span class="nav-number">2.6.</span> <span class="nav-text">radix_tree_tagged</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-gang-lookup"><span class="nav-number">2.7.</span> <span class="nav-text">radix_tree_gang_lookup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radix-tree-gang-lookup-tag"><span class="nav-number">2.8.</span> <span class="nav-text">radix_tree_gang_lookup_tag</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">qeandzc</p>
  <div class="site-description" itemprop="description">qeandzc的个人小站 -- linux kernel</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ohlinux.com/2-6-11%E7%89%88%E6%9C%AC%E5%9F%BA%E6%95%B0%E6%A0%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qeandzc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qeandzc的个人小站">
      <meta itemprop="description" content="qeandzc的个人小站 -- linux kernel">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="2.6.11版本基数树源码解析 | qeandzc的个人小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2.6.11版本基数树源码解析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-15 11:32:24" itemprop="dateCreated datePublished" datetime="2022-10-15T11:32:24+08:00">2022-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-31 22:14:24" itemprop="dateModified" datetime="2022-10-31T22:14:24+08:00">2022-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kernel-2-6-11/" itemprop="url" rel="index"><span itemprop="name">kernel 2.6.11</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kernel-2-6-11/%E5%9F%BA%E6%95%B0%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">基数树</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2-6-11%E7%89%88%E6%9C%AC%E5%9F%BA%E6%95%B0%E6%A0%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2-6-11版本基数树源码解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>文章深入源码解析了 2.6.11 版本的基数树实现。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init/main.c</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    radix_tree_init();</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">lib/radix-tree.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 kernel 中 RADIX_TREE_MAP_SHIFT 的值为 6，意味着将 index 看作是每 6 位一组，</span></span><br><span class="line"><span class="comment"> * 每一组对应每一层高的 offset，譬如当前树高为 3，要往这棵树中插入 index 65。那么可以将</span></span><br><span class="line"><span class="comment"> * 65 写成 0,000001,000001，所以 index 65 height 1 的 offset 为 0，height 2 的</span></span><br><span class="line"><span class="comment"> * offset 为 1，height 3 的 offset 为 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAP_SHIFT	6</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAP_SHIFT	3	<span class="comment">/* For more stressful testing */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RADIX_TREE_TAGS 为 2 是因为当前版本中只有两个 TAG，这两个 TAG 定义在 include/linux/fs.h 中：</span></span><br><span class="line"><span class="comment"> * #define PAGECACHE_TAG_DIRTY	0</span></span><br><span class="line"><span class="comment"> * #define PAGECACHE_TAG_WRITEBACK	1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_TAGS		2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RADIX_TREE_MAP_SIZE 定义了一个 radix_tree_node 有几个 slot，由于 RADIX_TREE_MAP_SHIFT 为 6，</span></span><br><span class="line"><span class="comment"> * 也就是说一个 radix_tree_node 最多可以有 64(1UL &lt;&lt; RADIX_TREE_MAP_SHIFT) 个slot。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAP_SIZE	(1UL &lt;&lt; RADIX_TREE_MAP_SHIFT)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RADIX_TREE_MAP_MASK 作用是防止 offset 溢出，在求 offset 时，只要按位与上 RADIX_TREE_MAP_MASK，所求得的</span></span><br><span class="line"><span class="comment"> * offset 肯定是在 [0，RADIX＿TREE＿MAP＿SIZE) 范围内的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAP_MASK	(RADIX_TREE_MAP_SIZE-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 上面讲到 RADIX_TREE_MAP_SIZE 定义了一个 radix_tree_node 有几个 slot，每个 slot 都有单独的 TAG 位，</span></span><br><span class="line"><span class="comment"> * RADIX_TREE_TAG_LONGS 定义了一个 radix_tree_node 的 slot 位图需要几个 1ong 类型才可以表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_TAG_LONGS	\</span></span><br><span class="line"><span class="meta">	((RADIX_TREE_MAP_SIZE + BITS_PER_LONG - 1) / BITS_PER_LONG)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * count：radix_tree_node 的计数，在从基数树中删除一个 index 时，会检查删除该 index 之后 count 是不是为 0，</span></span><br><span class="line"><span class="comment"> * 如果为 0，则释放该 radix_tree_node。</span></span><br><span class="line"><span class="comment"> * slots：一个 RADIX_TREE_MAP_SIZE 大小的数组，元素类型为 void*，其真实类型可以是 index 关联的 key 的真实类型，</span></span><br><span class="line"><span class="comment"> * 也可以是 struct radix_tree_node*。</span></span><br><span class="line"><span class="comment"> * tags：struct radix_tree_node 的 TAG 位图。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	count;</span><br><span class="line">	<span class="type">void</span>		*slots[RADIX_TREE_MAP_SIZE];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	tags[RADIX_TREE_TAGS][RADIX_TREE_TAG_LONGS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct radix_tree_path 用于 radix_tree_tag_clear 和 radix_tree_delete 函数，作用是</span></span><br><span class="line"><span class="comment"> * 记录 index 自 root 到叶子所经过的路径，而且需要查看 radix_tree_node 中各个 slot 的 TAG 情况，所以就</span></span><br><span class="line"><span class="comment"> * 需要 struct radix_tree_node *node; 和 int offset; 这两个成员了。offset 用于记录 slot 的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_path</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span>, **<span class="title">slot</span>;</span></span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 因为一颗基数树的 index 是以 unsigned long 类型表示的，</span></span><br><span class="line"><span class="comment"> * 所以这里求下 unsigned long 类型占用的比特数，就是一个 unsigned 1ong 类型数据有多少位</span></span><br><span class="line"><span class="comment"> * 用于防止 index 溢出。这里我们假设是 ILP32 数据模型，所以 RADIX_TREE_INDEX_BITS 为 32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_INDEX_BITS  (8 <span class="comment">/* CHAR_BIT */</span> * sizeof(unsigned long))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RADIX_TREE_MAX_PATH 表示基数树查找一个 index 最多经过这么多条路径。按理来说只要</span></span><br><span class="line"><span class="comment"> * RADIX_TREE_INDEX_BITS/RADIX_TREE_MAP_SHIFT + 1 就好，这里为什么 +2 呢？</span></span><br><span class="line"><span class="comment"> * 因为在下面的实现中基数树中有节点的话，它的树高至少为 1。树高为 0 的最大 index 是 0，相当于哨兵的作用。</span></span><br><span class="line"><span class="comment"> * 按照前面的假设，RADIX_TREE_MAX_PATH 值为 32/6 + 2 == 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAX_PATH (RADIX_TREE_INDEX_BITS/RADIX_TREE_MAP_SHIFT + 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * height＿to＿maxindex 数组存放基数树树高对应的最大 index</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> height_to_maxindex[RADIX_TREE_MAX_PATH];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Radix tree node cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> *radix_tree_node_cachep;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per-cpu pool of preloaded nodes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 struct radix_tree_preload 结构体定义了一个 percpu 变量 radix_tree_preloads</span></span><br><span class="line"><span class="comment"> * 一般在调用 radix_tree_insert 函数前会先调用 radix_tree_preload 函数填充 percpu 变量，</span></span><br><span class="line"><span class="comment"> * 存储 RADIX_TREE_MAX_PATH 个 struct radix_tree_node。</span></span><br><span class="line"><span class="comment"> * nr：缓存了几个 struct radix_tree_node</span></span><br><span class="line"><span class="comment"> * nodes： 存放分配的 struct radix_tree_node</span></span><br><span class="line"><span class="comment"> * TODO：为什么要设置这么一个 percpu 变量呢？缓和没有设置 __GFP_WAIT（不能睡眠） 分配失败？收益怎么样呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_preload</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">nodes</span>[<span class="title">RADIX_TREE_MAX_PATH</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里有个初始化，将 radix_tree_preloads 的 nr 和 nodes 都初始化为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFINE_PER_CPU(<span class="keyword">struct</span> radix_tree_preload, radix_tree_preloads) = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">radix_tree_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * radix_tree_node_cachep 用于分配 struct radix_tree_node，</span></span><br><span class="line"><span class="comment">     * 这里的 kmem_cache_create 带了 SLAB_PANIC 标记，表示如果 kmem_cache_create</span></span><br><span class="line"><span class="comment">     * 返回失败，则 panic。还有一点就是 radix_tree_node_ctor 构造函数了，这个函数具体见下面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	radix_tree_node_cachep = kmem_cache_create(<span class="string">&quot;radix_tree_node&quot;</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> radix_tree_node), <span class="number">0</span>,</span><br><span class="line">			SLAB_PANIC, radix_tree_node_ctor, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化 height_to_maxindex 数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	radix_tree_init_maxindex();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注册 cpu 热插拔回调函数，这是因为基数树中用了一个 percpu 变量 radix_tree_preloads</span></span><br><span class="line"><span class="comment">     * 来缓解内存分配失败的情况。不过这个热插拔回调不是做 radix_tree_preloads 的填充，而是</span></span><br><span class="line"><span class="comment">     * 要在 cpu 挂掉之后释放之前缓存的内存。</span></span><br><span class="line"><span class="comment">     * TODO：如果 cpu offline 时不释放，cpu online 之后可不可以继续使用这部分内存呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	hotcpu_notifier(radix_tree_callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 radix_tree_node_cachep 中分配 struct radix_tree_node 自动调用的构造函数，</span></span><br><span class="line"><span class="comment"> * 将 struct radix＿tree＿node 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">radix_tree_node_ctor</span><span class="params">(<span class="type">void</span> *node, <span class="type">kmem_cache_t</span> *cachep, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> radix_tree_node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化 height＿to＿maxindex 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __init <span class="type">void</span> <span class="title function_">radix_tree_init_maxindex</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(height_to_maxindex); i++)</span><br><span class="line">		height_to_maxindex[i] = __maxindex(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数是 height，返回值是 height 对应的最大 index</span></span><br><span class="line"><span class="comment"> * 假设 height 为 3，那么最大的 index 是 111111,111111,111111</span></span><br><span class="line"><span class="comment"> * 所以一个求法是 ~0UL &gt;&gt; (RADIX_TREE_INDEX_BITS - height * RADIX_TREE_MAP_SHIFT)，</span></span><br><span class="line"><span class="comment"> * 但直接这么做是有陷阱的，因为当 height 为0时，上面就相当于是 ~0UL &gt;&gt; 32了，</span></span><br><span class="line"><span class="comment"> * 这个在 K&amp;R Appendix-A.7.8 中写道：移位运算符...如果右操作数为负值，或者大于或等于左操作数</span></span><br><span class="line"><span class="comment"> * 类型的位数，则结果没有定义。</span></span><br><span class="line"><span class="comment"> * 所以 __maxindex 中使用了这样的技法：</span></span><br><span class="line"><span class="comment"> * (~0UL &gt;&gt; (RADIX_TREE_INDEX_BITS - height * RADIX_TREE_MAP_SHIFT - 1)) &gt;&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __init <span class="type">unsigned</span> <span class="type">long</span> __maxindex(<span class="type">unsigned</span> <span class="type">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tmp = height * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> index = (~<span class="number">0UL</span> &gt;&gt; (RADIX_TREE_INDEX_BITS - tmp - <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 按照上面的解释，当 RADIX_TREE_INDEX_BITS - tmp - 1 &gt;= 32 或者</span></span><br><span class="line"><span class="comment">     * RADIX_TREE_INDEX_BITS - tmp - 1 &lt; 0 时，index 的值是没有定义的。</span></span><br><span class="line"><span class="comment">     * 也就是 tmp &lt;= -1 或 tmp &gt; 31。tmp &lt;= -1 是不可能的，但是 tmp &gt; 31 是有可能的，</span></span><br><span class="line"><span class="comment">     * 而且 tmp &gt; 31 时，也就是 tmp &gt;= 32 时，index 是 ~9UL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (tmp &gt;= RADIX_TREE_INDEX_BITS)</span><br><span class="line">		index = ~<span class="number">0UL</span>;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cpu 热插拔函数</span></span><br><span class="line"><span class="comment"> * CPU＿DEAD 时将缓存的 node 释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">radix_tree_callback</span><span class="params">(<span class="keyword">struct</span> notifier_block *nfb,</span></span><br><span class="line"><span class="params">                            <span class="type">unsigned</span> <span class="type">long</span> action,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> *hcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> cpu = (<span class="type">long</span>)hcpu;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_preload</span> *<span class="title">rtp</span>;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Free per-cpu pool of perloaded nodes */</span></span><br><span class="line">       <span class="keyword">if</span> (action == CPU_DEAD) &#123;</span><br><span class="line">               rtp = &amp;per_cpu(radix_tree_preloads, cpu);</span><br><span class="line">               <span class="keyword">while</span> (rtp-&gt;nr) &#123;</span><br><span class="line">                       kmem_cache_free(radix_tree_node_cachep,</span><br><span class="line">                                       rtp-&gt;nodes[rtp-&gt;nr<span class="number">-1</span>]);</span><br><span class="line">                   		<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 * 释放之后将 node 置为 NULL</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">                       rtp-&gt;nodes[rtp-&gt;nr<span class="number">-1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">                       rtp-&gt;nr--;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HOTPLUG_CPU */</span></span></span><br></pre></td></tr></table></figure>



<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>基本的增删查操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入：<span class="type">int</span> <span class="title function_">radix_tree_insert</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">void</span> *item)</span>；</span><br><span class="line">删除：<span class="type">void</span> *<span class="title function_">radix_tree_delete</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index)</span>；</span><br><span class="line">查找：<span class="type">void</span> *<span class="title function_">radix_tree_lookup</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index)</span>；</span><br></pre></td></tr></table></figure>

<p>TAG 的基本操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入：<span class="type">void</span> *<span class="title function_">radix_tree_tag_set</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">int</span> tag)</span>；</span><br><span class="line">删除：<span class="type">void</span> *<span class="title function_">radix_tree_tag_clear</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">int</span> tag)</span>；</span><br><span class="line">测试树中有没有 tagged 的：<span class="type">int</span> <span class="title function_">radix_tree_tagged</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">int</span> tag)</span>；</span><br></pre></td></tr></table></figure>

<p>批量查找操作，为了更方便使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过 index 查找：</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">radix_tree_gang_lookup</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">void</span> **results,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> first_index, <span class="type">unsigned</span> <span class="type">int</span> max_items)</span>；</span><br><span class="line">通过 index + tag 查找：</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">radix_tree_gang_lookup_tag</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">void</span> **results,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> first_index, <span class="type">unsigned</span> <span class="type">int</span> max_items, <span class="type">int</span> tag)</span>；</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-insert"><a href="#radix-tree-insert" class="headerlink" title="radix_tree_insert"></a>radix_tree_insert</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_insert    -    insert into a radix tree</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@index:		index key</span></span><br><span class="line"><span class="comment"> *	@item:		item to insert</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Insert an item into the radix tree at position @index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 往基数树 root 中插入 index，值为 item。</span></span><br><span class="line"><span class="comment"> * 返回值：成功返回 0，失败返回错误码，如 -EEXIST。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">radix_tree_insert</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">void</span> *item)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>, *tmp, **slot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height, shift;</span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure the tree is high enough.  */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里是看当前的树高能不能存下传进来的 index，有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. index 为 0 时，为什么要对 0 特殊处理呢？因为 radix_tree_maxindex(0) 是 0，</span></span><br><span class="line"><span class="comment">     * 这使得 index 为 0 不能和其他 index 一样处理</span></span><br><span class="line"><span class="comment">     * 2. 其他 index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> ((!index &amp;&amp; !root-&gt;rnode) ||</span><br><span class="line">			index &gt; radix_tree_maxindex(root-&gt;height)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用 radix_tree_extend 扩展基数树，会更新 root-&gt;height 和 root-&gt;rnode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		error = radix_tree_extend(root, index);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 自上而下找到 index 对应的 slot，并将 item 插入</span></span><br><span class="line"><span class="comment">     * 所以 slot 为 &amp;root-&gt;rnode，height 为 root-&gt;height</span></span><br><span class="line"><span class="comment">     * shift：height 高度对应的偏移就是 (height-1) * RADIX_TREE_MAP_SHIFT;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	slot = &amp;root-&gt;rnode;</span><br><span class="line">	height = root-&gt;height;</span><br><span class="line">	shift = (height<span class="number">-1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 编译器警告消除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	offset = <span class="number">0</span>;			<span class="comment">/* uninitialised var warning */</span></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 还能跑进来就意味着 height 还不为 0， slot 是当前遍历 height，index 的父/祖先，</span></span><br><span class="line"><span class="comment">         * 如果此时为 NULL，即是这个 index 是第一个这个 slot 的孩子/孙子，所以要新分配一个 node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (*slot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">/* Have to add a child node.  */</span></span><br><span class="line">			<span class="keyword">if</span> (!(tmp = radix_tree_node_alloc(root)))</span><br><span class="line">				<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 将 slot 指向新分配的 node</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			*slot = tmp;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * node 是 *slot 的父节点，如果 node 存在(只要这时的 *slot 不是根节点，node 就存在)，</span></span><br><span class="line"><span class="comment">             * 因为增加了一个子节点，所以 count 要加 1</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			<span class="keyword">if</span> (node)</span><br><span class="line">				node-&gt;count++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Go a level down */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 求出 index 在当前 height 的 offset</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		offset = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node 是当前节点的子节点，下一次循环的 *slot 的父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		node = *slot;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 更新 slot, shift, height</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		slot = (<span class="keyword">struct</span> radix_tree_node **)(node-&gt;slots + offset);</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		height--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * index 对应的 slot，如果里面已经存放了东西，就表示 index 已经存在了，返回 -EEXIST</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (*slot != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 index 还不存在，node 是 index 对应的 slot 所在的 node，也就是 *slot 的父节点</span></span><br><span class="line"><span class="comment">     * 因为即将要将 item 放到 slot，后面不会再有错误，所以 node 的计数要加 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		node-&gt;count++;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 检查 tag 是否是没有设置的状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		BUG_ON(tag_get(node, <span class="number">0</span>, offset));</span><br><span class="line">		BUG_ON(tag_get(node, <span class="number">1</span>, offset));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 更新 *slot</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	*slot = item;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_insert);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Extend a radix tree so it can store key @index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扩展基数树使其可以存下 index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">radix_tree_extend</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height;</span><br><span class="line">	<span class="type">char</span> tags[RADIX_TREE_TAGS];</span><br><span class="line">	<span class="type">int</span> tag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Figure out what the height should be.  */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 计算 height 需要多大才可以容纳 index，因为原本 root-&gt;height 容纳不了，</span></span><br><span class="line"><span class="comment">     * 才会跑到这个函数，所以 height 至少是 root-&gt;height + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	height = root-&gt;height + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (index &gt; radix_tree_maxindex(height))</span><br><span class="line">		height++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 root-&gt;rnode 为 NULL，表示这棵树没有节点，所以不需要额外处理，</span></span><br><span class="line"><span class="comment">     * 直接将 root-&gt;height 置为 height 就可以</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;rnode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root-&gt;height = height;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Prepare the tag status of the top-level node for propagation</span></span><br><span class="line"><span class="comment">	 * into the newly-pushed top-level node(s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基数树中的 tag 是具有传播性质的，从下往上传播，即是如果子节点有这个 tag,</span></span><br><span class="line"><span class="comment">     * 那么其父节点肯定也会有这个 tag。所以在增加高度之前，判断下这个新增的 node 的 slots[0]</span></span><br><span class="line"><span class="comment">     * 需不需要设置某个 tag，为什么是 slots[0] 呢？因为所有旧节点的父/祖先节点肯定是新增节点的</span></span><br><span class="line"><span class="comment">     * slots[0]。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历所有 tag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">for</span> (tag = <span class="number">0</span>; tag &lt; RADIX_TREE_TAGS; tag++) &#123;</span><br><span class="line">		<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">		tags[tag] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 遍历 root-&gt;rnode 的所有 slots 的 tag</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; RADIX_TREE_TAG_LONGS; idx++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 只要其中一个设置了这个 tag，就设置 tags[tag] = 1</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			<span class="keyword">if</span> (root-&gt;rnode-&gt;tags[tag][idx]) &#123;</span><br><span class="line">				tags[tag] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 增加新节点，增加 root-&gt;height</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 分配 radix_tree_node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (!(node = radix_tree_node_alloc(root)))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Increase the height.  */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 旧节点是新节点的 slots[0] 的子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		node-&gt;slots[<span class="number">0</span>] = root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Propagate the aggregated tag info into the new root */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 根据上面的 tags[tag] 检查是否要给新节点的 slots[0] 设置 tag</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">for</span> (tag = <span class="number">0</span>; tag &lt; RADIX_TREE_TAGS; tag++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tags[tag])</span><br><span class="line">				tag_set(node, tag, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 因为 slots[0] 有值了，所以 count 要置为 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		node-&gt;count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 新的 root-&gt;rnode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		root-&gt;rnode = node;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 更新 root-&gt;height</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		root-&gt;height++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (height &gt; root-&gt;height);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This assumes that the caller has performed appropriate preallocation, and</span></span><br><span class="line"><span class="comment"> * that the caller has pinned this thread of control to the current CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配 radix_tree_node，成功返回 分配的地址，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> radix_tree_node *</span><br><span class="line"><span class="title function_">radix_tree_node_alloc</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 先通过 radix_tree_node_cachep 分配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	ret = kmem_cache_alloc(radix_tree_node_cachep, root-&gt;gfp_mask);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmem_cache_alloc 分配失败，__GFP_WAIT 和慢速分配有关，如果没有设置 __GFP_WAIT，</span></span><br><span class="line"><span class="comment">     * 则不会进入同步回收分配内存，设置了 __GFP_WAIT 标志可能会睡眠，这在某些场景下是不允许的。</span></span><br><span class="line"><span class="comment">     * 这时候会使用全局的 radix_tree_preloads 分配内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="literal">NULL</span> &amp;&amp; !(root-&gt;gfp_mask &amp; __GFP_WAIT)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_preload</span> *<span class="title">rtp</span>;</span></span><br><span class="line"></span><br><span class="line">		rtp = &amp;__get_cpu_var(radix_tree_preloads);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 查看是否有 preload 的内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (rtp-&gt;nr) &#123;</span><br><span class="line">			ret = rtp-&gt;nodes[rtp-&gt;nr - <span class="number">1</span>];</span><br><span class="line">			rtp-&gt;nodes[rtp-&gt;nr - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">			rtp-&gt;nr--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-delete"><a href="#radix-tree-delete" class="headerlink" title="radix_tree_delete"></a>radix_tree_delete</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_delete    -    delete an item from a radix tree</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@index:		index key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Remove the item at @index from the radix tree rooted at @root.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns the address of the deleted item, or NULL if it was not present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从基数树 root 中删除 index，如果 index 存在，返回里面的 item，否则返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">radix_tree_delete</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_path</span> <span class="title">path</span>[<span class="title">RADIX_TREE_MAX_PATH</span>], *<span class="title">pathp</span> =</span> path;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_path</span> *<span class="title">orig_pathp</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height, shift;</span><br><span class="line">	<span class="type">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> tags[RADIX_TREE_TAGS];</span><br><span class="line">	<span class="type">int</span> nr_cleared_tags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * index 已经超出这棵树的最大 index，返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	height = root-&gt;height;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; radix_tree_maxindex(height))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * shift 是 height 对应的偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shift = (height - <span class="number">1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * slot 保存的是下一层 node 的地址或者 index 对应的 item，</span></span><br><span class="line"><span class="comment">     * node 是当前层 node，</span></span><br><span class="line"><span class="comment">     * 所以一开始 node 为 NULL, slot 为 &amp;root-&gt;rnode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	pathp-&gt;node = <span class="literal">NULL</span>;</span><br><span class="line">	pathp-&gt;slot = &amp;root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从高到低遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果这个 slot 里面没有东西（下一层 node 的地址或 item）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (*pathp-&gt;slot == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里的写法有点奇怪，用的是 pathp[1]，下面 pathp++</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		offset = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line">		pathp[<span class="number">1</span>].offset = offset;</span><br><span class="line">		pathp[<span class="number">1</span>].node = *pathp[<span class="number">0</span>].slot;</span><br><span class="line">		pathp[<span class="number">1</span>].slot = (<span class="keyword">struct</span> radix_tree_node **)</span><br><span class="line">				(pathp[<span class="number">1</span>].node-&gt;slots + offset);</span><br><span class="line">		pathp++;</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		height--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注意这里的 pathp 经过上面的循环之后已经是最后一层了</span></span><br><span class="line"><span class="comment">     * 如果这个 slot 里面没东西，就表示这个 index 不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	ret = *pathp[<span class="number">0</span>].slot;</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 保存倒序的 pathp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	orig_pathp = pathp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear all tags associated with the just-deleted item</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 清除这个路径上的 tag。</span></span><br><span class="line"><span class="comment">     * 因为删除了这个 index 之后，如果没有其他 index 也设置了这个 tag，</span></span><br><span class="line"><span class="comment">     * 这条路径的 tag 也需要被清掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="built_in">memset</span>(tags, <span class="number">0</span>, <span class="keyword">sizeof</span>(tags));</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">int</span> tag;</span><br><span class="line"></span><br><span class="line">		nr_cleared_tags = RADIX_TREE_TAGS;</span><br><span class="line">		<span class="keyword">for</span> (tag = <span class="number">0</span>; tag &lt; RADIX_TREE_TAGS; tag++) &#123;</span><br><span class="line">			<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这条路径还有 slot 设置了这个 tag，所以不需要做清除操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			<span class="keyword">if</span> (tags[tag])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			tag_clear(pathp[<span class="number">0</span>].node, tag, pathp[<span class="number">0</span>].offset);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 查看这个 node 是否还有 slot 设置了这个 tag</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			<span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; RADIX_TREE_TAG_LONGS; idx++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pathp[<span class="number">0</span>].node-&gt;tags[tag][idx]) &#123;</span><br><span class="line">					tags[tag] = <span class="number">1</span>;</span><br><span class="line">					nr_cleared_tags--;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pathp--;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pathp[<span class="number">0</span>].node &amp;&amp; nr_cleared_tags);</span><br><span class="line"></span><br><span class="line">	pathp = orig_pathp;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 清除 item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	*pathp[<span class="number">0</span>].slot = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将 node 计数减 1，如果计数为 0 就释放这个 node。释放了这个 node 之后</span></span><br><span class="line"><span class="comment">     * 上一层的 node 计数可能也变为了 0，也需要释放。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">while</span> (pathp[<span class="number">0</span>].node &amp;&amp; --pathp[<span class="number">0</span>].node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">		pathp--;</span><br><span class="line">		BUG_ON(*pathp[<span class="number">0</span>].slot == <span class="literal">NULL</span>);</span><br><span class="line">		*pathp[<span class="number">0</span>].slot = <span class="literal">NULL</span>;</span><br><span class="line">		radix_tree_node_free(pathp[<span class="number">1</span>].node);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于基数树的插入特点：插入由于高度不够时，增加树高的方法是将子树的根节点作为新的根节点的子节点。</span></span><br><span class="line"><span class="comment">     * 所以只要 root-&gt;rnode 没有被删除，树高就不需要改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;rnode == <span class="literal">NULL</span>)</span><br><span class="line">		root-&gt;height = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_delete);</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-lookup"><a href="#radix-tree-lookup" class="headerlink" title="radix_tree_lookup"></a>radix_tree_lookup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_lookup    -    perform lookup operation on a radix tree</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@index:		index key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Lookup the item at the position @index in the radix tree @root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找 index，index 不存在返回 NULL，存在返回 item</span></span><br><span class="line"><span class="comment"> * 这个函数基本就是 radix_tree_delete 的前面那部分实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">radix_tree_lookup</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">unsigned</span> <span class="type">long</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height, shift;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> **<span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * index 超出树表示的范围，肯定不存在，返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	height = root-&gt;height;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; radix_tree_maxindex(height))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	shift = (height<span class="number">-1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">	slot = &amp;root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 和 radix_tree_delete 一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*slot == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里的 (*slot) 是 radix_tree_delete 的 pathp[1].node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		slot = (<span class="keyword">struct</span> radix_tree_node **)</span><br><span class="line">			((*slot)-&gt;slots +</span><br><span class="line">				((index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK));</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		height--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *slot;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_lookup);</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-tag-set"><a href="#radix-tree-tag-set" class="headerlink" title="radix_tree_tag_set"></a>radix_tree_tag_set</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_tag_set - set a tag on a radix tree node</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@index:		index key</span></span><br><span class="line"><span class="comment"> *	@tag: 		tag index</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Set the search tag corresponging to @index in the radix tree.  From</span></span><br><span class="line"><span class="comment"> *	the root all the way down to the leaf node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns the address of the tagged item.   Setting a tag on a not-present</span></span><br><span class="line"><span class="comment"> *	item is a bug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个函数和 radix_tree_lookup 几乎一模一样，只不过多了一个 tag_set 调用</span></span><br><span class="line"><span class="comment"> * index 存在返回 item，不存在返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">radix_tree_tag_set</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">int</span> tag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height, shift;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> **<span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">	height = root-&gt;height;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; radix_tree_maxindex(height))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	shift = (height - <span class="number">1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">	slot = &amp;root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">		offset = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line">		tag_set(*slot, tag, offset);</span><br><span class="line">		slot = (<span class="keyword">struct</span> radix_tree_node **)((*slot)-&gt;slots + offset);</span><br><span class="line">		BUG_ON(*slot == <span class="literal">NULL</span>);</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		height--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *slot;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_tag_set);</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-tag-clear"><a href="#radix-tree-tag-clear" class="headerlink" title="radix_tree_tag_clear"></a>radix_tree_tag_clear</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_tag_clear - clear a tag on a radix tree node</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@index:		index key</span></span><br><span class="line"><span class="comment"> *	@tag: 		tag index</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Clear the search tag corresponging to @index in the radix tree.  If</span></span><br><span class="line"><span class="comment"> *	this causes the leaf node to have no tags set then clear the tag in the</span></span><br><span class="line"><span class="comment"> *	next-to-leaf node, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns the address of the tagged item on success, else NULL.  ie:</span></span><br><span class="line"><span class="comment"> *	has the same return value and semantics as radix_tree_lookup().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个函数和 readix_tree_delete 几乎一模一样</span></span><br><span class="line"><span class="comment"> * 返回 item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">radix_tree_tag_clear</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">int</span> tag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_path</span> <span class="title">path</span>[<span class="title">RADIX_TREE_MAX_PATH</span>], *<span class="title">pathp</span> =</span> path;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height, shift;</span><br><span class="line">	<span class="type">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	height = root-&gt;height;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; radix_tree_maxindex(height))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	shift = (height - <span class="number">1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">	pathp-&gt;node = <span class="literal">NULL</span>;</span><br><span class="line">	pathp-&gt;slot = &amp;root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*pathp-&gt;slot == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		offset = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line">		pathp[<span class="number">1</span>].offset = offset;</span><br><span class="line">		pathp[<span class="number">1</span>].node = *pathp[<span class="number">0</span>].slot;</span><br><span class="line">		pathp[<span class="number">1</span>].slot = (<span class="keyword">struct</span> radix_tree_node **)</span><br><span class="line">				(pathp[<span class="number">1</span>].node-&gt;slots + offset);</span><br><span class="line">		pathp++;</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		height--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = *pathp[<span class="number">0</span>].slot;</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里和 radix_tree_delete 稍有不同是因为删除需要判断两个 tag，这里只清除一个 tag</span></span><br><span class="line"><span class="comment">     * 所以只对一个 tag 做处理就行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">		tag_clear(pathp[<span class="number">0</span>].node, tag, pathp[<span class="number">0</span>].offset);</span><br><span class="line">		<span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; RADIX_TREE_TAG_LONGS; idx++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pathp[<span class="number">0</span>].node-&gt;tags[tag][idx])</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		pathp--;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pathp[<span class="number">0</span>].node);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_tag_clear);</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-tagged"><a href="#radix-tree-tagged" class="headerlink" title="radix_tree_tagged"></a>radix_tree_tagged</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_tagged - test whether any items in the tree are tagged</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@tag:		tag to test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 简单明了的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">radix_tree_tagged</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">int</span> tag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!root-&gt;rnode)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; RADIX_TREE_TAG_LONGS; idx++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;rnode-&gt;tags[tag][idx])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_tagged);</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-gang-lookup"><a href="#radix-tree-gang-lookup" class="headerlink" title="radix_tree_gang_lookup"></a>radix_tree_gang_lookup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_gang_lookup - perform multiple lookup on a radix tree</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@results:	where the results of the lookup are placed</span></span><br><span class="line"><span class="comment"> *	@first_index:	start the lookup from this key</span></span><br><span class="line"><span class="comment"> *	@max_items:	place up to this many items at *results</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Performs an index-ascending scan of the tree for present items.  Places</span></span><br><span class="line"><span class="comment"> *	them at *@results and returns the number of items which were placed at</span></span><br><span class="line"><span class="comment"> *	*@results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	The implementation is naive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 批量查找，results 存放查找到的 item，first_index 是开始查找的 index，</span></span><br><span class="line"><span class="comment"> * max_items 表示最多查找这么多个</span></span><br><span class="line"><span class="comment"> * 返回值是最终找到多少个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">radix_tree_gang_lookup</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">void</span> **results,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> first_index, <span class="type">unsigned</span> <span class="type">int</span> max_items)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> max_index = radix_tree_maxindex(root-&gt;height);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cur_index = first_index;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ret &lt; max_items) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> nr_found;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> next_index;	<span class="comment">/* Index of next search */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当下一个要开始查找的 index 比树表示的 index 还要大时，表示已经查找结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (cur_index &gt; max_index)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 详情看下面</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nr_found = __lookup(root, results + ret, cur_index,</span><br><span class="line">					max_items - ret, &amp;next_index);</span><br><span class="line">		ret += nr_found;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * next_index 为 0 表示已经遍历完整棵树了，不会重头开始遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (next_index == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		cur_index = next_index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_gang_lookup);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__lookup(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">void</span> **results, <span class="type">unsigned</span> <span class="type">long</span> index,</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_items, <span class="type">unsigned</span> <span class="type">long</span> *next_index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_found = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shift;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height = root-&gt;height;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">	shift = (height<span class="number">-1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">	slot = root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> i = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个 for 循环是查找的重点，当当前 index 对应的 slot 找不到元素时，</span></span><br><span class="line"><span class="comment">         * 当前 height 的偏移要加 1，而更底层的 offset 要从 0 开始。</span></span><br><span class="line"><span class="comment">         * 譬如 height 为 3 的树，传入的 index 为 3,4,5。假设 3 找不到 node，</span></span><br><span class="line"><span class="comment">         * 那么就要更新 index 为 4,0,0。假设 3 找得到，4找不到，那么 index </span></span><br><span class="line"><span class="comment">         * 就要更新为 3,5,0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">for</span> ( ; i &lt; RADIX_TREE_MAP_SIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (slot-&gt;slots[i] != <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			index &amp;= ~((<span class="number">1UL</span> &lt;&lt; shift) - <span class="number">1</span>);</span><br><span class="line">			index += <span class="number">1UL</span> &lt;&lt; shift;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当 index 为 0，表示基数树已经不能再继续往下走了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;	<span class="comment">/* 32-bit wraparound */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == RADIX_TREE_MAP_SIZE)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		height--;</span><br><span class="line">		<span class="keyword">if</span> (height == <span class="number">0</span>) &#123;	<span class="comment">/* Bottom level: grab some items */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> j = index &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> ( ; j &lt; RADIX_TREE_MAP_SIZE; j++) &#123;</span><br><span class="line">				index++;</span><br><span class="line">				<span class="keyword">if</span> (slot-&gt;slots[j]) &#123;</span><br><span class="line">					results[nr_found++] = slot-&gt;slots[j];</span><br><span class="line">					<span class="keyword">if</span> (nr_found == max_items)</span><br><span class="line">						<span class="keyword">goto</span> out;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		slot = slot-&gt;slots[i];</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	*next_index = index;</span><br><span class="line">	<span class="keyword">return</span> nr_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="radix-tree-gang-lookup-tag"><a href="#radix-tree-gang-lookup-tag" class="headerlink" title="radix_tree_gang_lookup_tag"></a>radix_tree_gang_lookup_tag</h2><p>这个函数和 radix_tree_gang_lookup 几乎一模一样，就不再解析了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	radix_tree_gang_lookup_tag - perform multiple lookup on a radix tree</span></span><br><span class="line"><span class="comment"> *	                             based on a tag</span></span><br><span class="line"><span class="comment"> *	@root:		radix tree root</span></span><br><span class="line"><span class="comment"> *	@results:	where the results of the lookup are placed</span></span><br><span class="line"><span class="comment"> *	@first_index:	start the lookup from this key</span></span><br><span class="line"><span class="comment"> *	@max_items:	place up to this many items at *results</span></span><br><span class="line"><span class="comment"> *	@tag:		the tag index</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Performs an index-ascending scan of the tree for present items which</span></span><br><span class="line"><span class="comment"> *	have the tag indexed by @tag set.  Places the items at *@results and</span></span><br><span class="line"><span class="comment"> *	returns the number of items which were placed at *@results.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">radix_tree_gang_lookup_tag</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">void</span> **results,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> first_index, <span class="type">unsigned</span> <span class="type">int</span> max_items, <span class="type">int</span> tag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> max_index = radix_tree_maxindex(root-&gt;height);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cur_index = first_index;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ret &lt; max_items) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> nr_found;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> next_index;	<span class="comment">/* Index of next search */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cur_index &gt; max_index)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		nr_found = __lookup_tag(root, results + ret, cur_index,</span><br><span class="line">					max_items - ret, &amp;next_index, tag);</span><br><span class="line">		ret += nr_found;</span><br><span class="line">		<span class="keyword">if</span> (next_index == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		cur_index = next_index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_gang_lookup_tag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">FIXME:</span> the two tag_get()s here should use find_next_bit() instead of</span></span><br><span class="line"><span class="comment"> * open-coding the search.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__lookup_tag(<span class="keyword">struct</span> radix_tree_root *root, <span class="type">void</span> **results, <span class="type">unsigned</span> <span class="type">long</span> index,</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_items, <span class="type">unsigned</span> <span class="type">long</span> *next_index, <span class="type">int</span> tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_found = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shift;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> height = root-&gt;height;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">	shift = (height - <span class="number">1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line">	slot = root-&gt;rnode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> i = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ( ; i &lt; RADIX_TREE_MAP_SIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tag_get(slot, tag, i)) &#123;</span><br><span class="line">				BUG_ON(slot-&gt;slots[i] == <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			index &amp;= ~((<span class="number">1UL</span> &lt;&lt; shift) - <span class="number">1</span>);</span><br><span class="line">			index += <span class="number">1UL</span> &lt;&lt; shift;</span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;	<span class="comment">/* 32-bit wraparound */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == RADIX_TREE_MAP_SIZE)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		height--;</span><br><span class="line">		<span class="keyword">if</span> (height == <span class="number">0</span>) &#123;	<span class="comment">/* Bottom level: grab some items */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> j = index &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> ( ; j &lt; RADIX_TREE_MAP_SIZE; j++) &#123;</span><br><span class="line">				index++;</span><br><span class="line">				<span class="keyword">if</span> (tag_get(slot, tag, j)) &#123;</span><br><span class="line">					BUG_ON(slot-&gt;slots[j] == <span class="literal">NULL</span>);</span><br><span class="line">					results[nr_found++] = slot-&gt;slots[j];</span><br><span class="line">					<span class="keyword">if</span> (nr_found == max_items)</span><br><span class="line">						<span class="keyword">goto</span> out;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">		slot = slot-&gt;slots[i];</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	*next_index = index;</span><br><span class="line">	<span class="keyword">return</span> nr_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kernel-2-6-11/" rel="tag"># kernel 2.6.11</a>
              <a href="/tags/%E5%9F%BA%E6%95%B0%E6%A0%91/" rel="tag"># 基数树</a>
              <a href="/tags/radix-tree/" rel="tag"># radix tree</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E6%90%AD%E5%BB%BA-hexo-%E5%8D%9A%E5%AE%A2/" rel="prev" title="搭建 hexo 博客">
                  <i class="fa fa-chevron-left"></i> 搭建 hexo 博客
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E5%88%A9%E7%94%A8-page-owner-%E8%B7%9F%E8%B8%AA-page-flags/" rel="next" title="利用 page_owner 跟踪 page flags">
                  利用 page_owner 跟踪 page flags <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qeandzc</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.2.2/mermaid.min.js","integrity":"sha256-o5AUfgOkNFWuInA78GVCoVdGoN9eTaB3Hxu+ep7TTrY="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"persuepersue","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
